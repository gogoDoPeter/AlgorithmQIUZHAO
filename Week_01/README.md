学习笔记和总结：

准备：时间复杂度、空间复杂度分析
时间复杂度主要看用了几次循环，一些暂时不理解的(比如Skip List插入、删除、访问，搜索都是O(logn)，空间复杂度都是O(n))，
要先熟记，多看多思考来理解；
空间复杂度主要看额外空间使用多少；



学习方法：
眼过千遍不如手过一遍
最大误区就是做一遍；
优化核心是升维，用空间换时间。
遇到不懂的，不理解的上五毒神掌；如果理解的定期重复练习，常用的套嵌循或者经典公式要熟练记忆背诵；

☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
学习时间：视频三分练习七分；
把全部时间都用上，零碎的和下班整块的，在第二周要把第一周没做的课程和习题补上；
Week01练习题，下周二重复一遍，下下周二再重复一遍；
加油，搞定算法，拿下大厂Offer你可以的。
☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆


1，数组、链表、跳表
				     时间复杂度								    空间复杂度
				prepend  append  lookup  insert  delete |  prepend  append  lookup  insert delete
Linked List      O(1) 	 O(1)	  O(n)	   O(1)   O(1)  |  
Array			 O(1)    O(1)	  O(1)	   O(n)   O(n)  |

跳表：只能用于元素有序情况

2，栈、队列、优先队列、双端队列
Stack：LIFO  
添加、删除为O(1)

Queue： FIFO
添加、删除为O(1)
	Deque(double-ended queue)：两端可以进出的Queue
	最常用的queue，本质是
	插入和删除都是O(1)操作

Priority Queue：
	插入操作O(1),取出操作O(logn),按照元素的优先级取出
	底层具体实现的数据结构较为多样和复杂：heap，bst，treap
	bst：Binary Search Tree，access,search,del && insert时间复杂度是O(log(n))
	
解读分析Stack、Queue的Java 源码实现，其他Priority Queue如何分析源码及接口API的熟练使用


